A “design document” for your project in the form of a Markdown file called DESIGN.md that discusses, technically, how you implemented your project and why you made the design decisions you did. Your design document should be at least several paragraphs in length. Whereas your documentation is meant to be a user’s manual, consider your design document your opportunity to give the staff a technical tour of your project underneath its hood.

# General Overview

Our website is meant to be used in collaboration with an informal QuestBridge affiliate organization (currently called "FGLI Home") that was meant to help high school seniors feel more supported during their application procress. Our website's main purpose is to use data from the surveys mentees and mentors take, and then match mentees and mentors based on this data. Previously, the administrators of FGLI Home had done the matching process manually and used Google forms to collect answers. This made matching both tedious and almost impossible to do in a timely manner, so we offered to help solve the issue. In the process, we decided to expand our website's utility to be useful even after the match process, so we incoperated features on a mentor-facing dashboard and mentee-facing dashboard as well. The first step was deciding where we would code our website.

# Hannah Start: Talk about codespace vs visual-code

# Hannah End

# About Homepage
Typically, our users will encounter the homepage first. Our goal was to give our homepage a simple, clean look so that everything could be found easily and for that we used bootsrap templates and combined the features we liked, as well as worked on creating a color-scheme. For users unsure of how our website works and how to match occurs, we have listed the process of the match, as well as website's purpose and a link to the original Discord responsible for creating the community which the match will aid. In this page, we have tabs that lead to the login page as well as the register page.

# About Forms
We took great care in deciding what information we wanted our forms and thought of our target audience as follows: busy people looking for efficiency. The college process and mentoring those going through it is hectic, which is why we only included what we thought absolutely necessary to our forms. We took inspiration from FGLI Home's prior forms, but decided to standardized the information to make matching more efficient. To register, we asked only for essential information for mentees and mentors to keep in contact with each other and added "Discord Tag" as a fill-in as well because most of the FGLI Home occurs through Discord. Then, we debated whether after filling out registration forms, we should direct the user to their individual dashboards or continue on with the survey. Although many websites typically choose to go straight to dashboards, we decided to continue onto the survey to make it a quick procress to get matched, especially considering that is our website's primary purpose.

Designing the survey itself was a lot more complicated. As mentioned before, we knew we had to standardize the surveys so the matching would be effective, but we were unsure on how to pick and choose the questions and options we should provide. For that, we contacted a few FGLI Home mentees and asked for their opinions on the questions provided in previous forms and were able to narrow down the questions to only essentials that mentees find most important (gender, race, academic interest, etc.). Then, it came down to options. We discussed the possibility of incorporating short responses, multiple select, and/or single choice answers. Short responses were quickly discarded as an option not only because they would be time-consuming to analyze in an algorithm, but also because many mentees agreed that having to fill out short responses while also having college supplements and essays would discourage them from filling out the form. In deciding between multiple select and single choice, we debated the benefits of each and how much sense they would make in the context of their question. For most questions such as gender and religion, we agreed that there is very little to none probability that someone would select more than one option, so we left them single choice. For the question of ethnicity/race, we allowed multiple select because of potential mixed races and generally because ethnicity/race is harder to define in one box.

To give mentees more control over the match, we also allowed them to rank the importance of having a mentor that matches them in certain criteria, such as religion or race, with importance of 1 (very important) to 5 (unimportant). This would allow us to give more accurate matches. The framework of the forms were set, the layout was a basic color-grandient faded background with our color scheme to keep the attention on the forms. Now, it was time to focus on the database, and what exactly that would look like.

Another major focus on the creation of forms was determining which values to assign to each option. That is directly tied to how we decided to implement the databases later on. More on this in the following section.

# Hannah Start: Talk about databases, its design, why it is designed that way, and how it is tied to what the database is drawing from the forms

# Hannah End

# About Algorithm

Before coding our algorithm, we had two major ideas: either compute a match score and match by highest scores, or use SQL to weed out mentors who don't match the mentee's preferences (given their order of importance as they ranked in the survey). First, we considered user experience. By computing match scores, we would be making the algorithm far more holistic and avoiding weeding out mentors who could be better matches overall based on their other criteria. For example, if a mentee rank academic interest 1 and the rest 3s, a mentor who matches all the rest but not academic interest would still, theoretically, be a better match than a mentor who only matches academic interest. Then, we considered difficulty of implementation. The less holistic approach would definitely be easier to code, but in itself could arise many issues. For example, because it is so absolute, it could easy weed out all mentors and result in no match for some of the mentees. For these reasons, we chose to find a way to compute a match score.

For our algorithm, we took inspiration from the general formula to calculate weighted high school GPAs, giving higher ranked categories higher weight. Then, the mathematical aspect would be simple:

score = SUM( weight of category * (number of successful matching selections/overall selections))

We then ran into the problem of how exactly we should write code to match mentees with mentors. We thought about how each mentee would have to interate through each mentor and compute a score and then choose the highest one, but storing all these scores would take up a lot of space and prove to be difficult to organize in a table. Thus, we had to make decisions on what the priority is. We thought of using a bubble sorting mechanism to gradually only save the highest score with two temporary holders of previous score and current score changing values through each iteration. Then, we could assign the mentee the mentor with which they had the highest score, and save this match into a table called "matches." "Matches" stores the mentor's id, mentee's id, and the score of the match made. Although this would mean that the mentees that get matched first have a higher chance of finding a better match because they get to choose from more mentors, this was a small downside compared to slowing down the run time and using up too much storage.

For this algorithm, we also had to keep in mind that each mentor selects the number of mentees they are willing to take on. This would mean that even if a mentee was matched with a mentor, that doesn't mean the same mentor can't be matched without even more mentees. We had to find a way to keep track of how many mentees the mentor could take on, sort of like a counter, and then make sure that after the mentor's slots have been filled no more mentees can be matched to that mentor. To do this, we ran through the number of mentors in the database (table named "users") and then pulled out the number of mentees they were willing to take. We called this mentees_left, and every time we interate through the algorithm and a mentee is matched to a mentor, the mentor's mentees_left decreases by one. When that mentees_left reaches 0, the algorithm no longer iterates through that mentor's information as they are unavailable.

We were stuck between two options, allow the data from the survey to be directly modified for mentors where they put the amount of mentees they were willing to take in, or create some sort of new table with counters for each mentor's preferences. We decided on the latter for the reason that if we decided to upgrade our code in the future, we would want to have a feature where the mentor could update their mentee uptake preferences. That way, if we had a shortage of mentors in a certain cycle, we could send an alert to all mentors asking if they would be willing to update their preferences to take in more mentees and hopefully get more mentees matched.

And along that train of thought, we stumbled upon the question, what if we have more mentees than the mentors are willing to take? We discussed potentially having an emergency list of mentors who might be willing to take on mentees for shorter periods of time. With the time contraints, however, we were unable to reasonably compose a solid list of backup mentors. To still handle the problem, we chose to incorporate a waitlist for mentees without mentors. This way we would let the mentees know that their information was processsed, and that upon having more mentors, they could be matched. The database question came up again during this time: where will we signify that these mentees are waitlisted? To save space in the database and keep everything as concise as possible, we decided to put these waitlisted mentees on the "matches" table as well, and instead of having a mentor's id on their row, they will have a 0 signifying waitlist.

Now that the algorithm was fleshed out, we needed to decide when to run it. Typically, these sorts of matches have cycles with deadlines. Considering that each mentee would have to iterate through every mentor, we figured that it would be much better if we already had all the mentors registered before the mentees because that gives the mentees more options. As such, we decided to run the algorithm every time a mentee takes the survey and have the mentors register before the mentee's application opens. In theory, this would work in sort of a first-come, first-serve basis, but it allows for the algorithm to remain in a fixed place in our code and still function accordingly.

# Dashboards

The dashboards are displayed after the registration and survey process. The design was heavily inspired by multiple Bootstrap dashboards,but required a lot of tinkering and trial-and-error to get only what we wanted to display. Most of the JavaScript functionality, however, came from Bootstrap. The basic dashboard has a side bar with the four component tabs: returning to main dashboard, notetaker, scheduler, and resources. Each mentee and mentors has their own dashboard with multiple uses. 

# View Matches

The first use on the main dashboard: being able to view their mentor's or mentees's information, including essential communication information and their profiles. This was a simple pulling from the survey's information stored in the database, using JINJA to them copy the information into the dashboard's html files. Within the app.py file, we simply looked at the "matches" table to figure out each mentee's and mentor's corresponding matches' id and search for the necessary information using those ids. This is the same process we use every time we want to give users specific information about their matches.

# Scheduler

On the side bar, there is a tab labeled "scheduler." This feature was up to debate many times, as we took a lot of time researching how to use Google Calendar APIs and the iframe tag in HTML along with other methods. Google APIs quickly turned out to be very time consuming and difficult to follow, with no access to a slower paced step-by-step guide. With iframe, we realized that we could only link our own individual calendars to the website, which would mean they wouldn't be personalized to our users. As time began to run out and none were successful, we turned to creating our own, simple version of a scheduler. We modeled our displayer after the Finance PSET's history menu, to be displayed in the main dashboard. The actual schedule was a quick put together using the convenient time and dates type HTML tags along with allowing a space for URLs for virtual meetings. This information is stored in a table called "meets" which keeps track of who requested the meeting, with who, when, and where (url). 

On the mentor's side, considering they have more potential people to schedule meetings with, we passed on the information from the "matches" table to variable that stores the mentees's names, and then we passed it onto the HTML using JINJA to display the mentee options to the mentor in the scheduler form. This way, the mentor can select who to schedule a meeting with and that mentee will then see that meeting on their own dashboard. The mentee's side is less complicated as each mentee only has one mentor and thus any meeting schedule will simply appear on their respective mentor's scheduled meetings table on their main dashboard as well as their own.

# Notetaking

This feature was directly pulled from an online source, but the purpose is to allow the users to keep track of notes taken about the mentorship, college process, future questions, etc.

https://www.geeksforgeeks.org/how-to-create-notes-taking-site-using-html-bootstrap-and-javascript/


# Resources

This tab simply contains a list of well-known resources for college applicants to both give mentor's insight on how to advice mentees and also give mentees the ability to reference the resources as well. This is hard-coded into the resources html file, using the basic "a" tags and "p" tags.